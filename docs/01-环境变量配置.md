# 环境变量配置规范

## 引言

环境变量是自动化测试框架中管理配置差异、保障敏感信息安全以及实现灵活部署的关键机制。本规范旨在统一环境变量的使用方式，确保配置的清晰性、安全性和可维护性，适用于开发、测试和生产等多种环境。

## 核心原则

1.  **配置分离**:
    *   **框架核心配置 (`config/settings.yaml`)**: 定义基础结构、通用默认值（如默认超时、日志格式）和与环境无关的设置。**不应**包含环境特定的URL、凭据或与特定UI强耦合的选择器。可使用 `${env:VAR_NAME:-default}` 提供默认值。
    *   **环境特定配置 (`config/env/*.yaml`)**: 定义特定环境的差异，如 `base_url`。通过 `${env:VAR_NAME}` 引用环境变量获取凭据、密钥等。
    *   **项目特定配置**: UI选择器、特定业务流开关等，应由使用框架的具体项目自行定义（如 `project_config.yaml`），框架提供加载机制。

2.  **敏感信息外部化**:
    *   **严禁**在代码或配置文件中硬编码密码、API密钥、Token等敏感信息。
    *   **必须**通过环境变量或安全的Secrets Management机制提供。

3.  **环境变量优先**:
    *   环境变量应具有最高优先级，能够覆盖所有配置文件中的同名设置。

## 环境标识变量

- **`APP_ENV`**: 核心环境标识变量，用于指定当前运行的环境（如 `test`, `prod`）。
  - 本地开发: 在 `.env` 文件中设置（如 `APP_ENV=test`）。
  - CI/CD: 基于分支、标签或手动触发器设置。
  - 影响: 决定加载哪个环境配置文件（`config/env/{APP_ENV}.yaml`）。
  
这是最基础的环境变量之一，在配置加载的最初阶段就会被使用，不应缺失。

## 文件职责

1.  **`.env.example`**:
    *   **作用**: 作为模板文件，列出框架和项目运行所需的**所有**环境变量名称。
    *   **内容**:
        *   包含变量名。
        *   提供**非敏感**的示例值或留空。
        *   使用**通用、描述性**的变量名（如 `TEST_ADMIN_USERNAME`, `WEB_BASE_URL`），避免与特定系统过度耦合。
    *   **版本控制**: **必须**提交到版本控制库。

    ```dotenv
    # .env.example 内容示例
    # -------------------------
    # 运行环境
    APP_ENV=test
    
    # Web 应用基础 URL
    WEB_BASE_URL=

    # API 基础 URL
    API_BASE_URL=

    # 测试环境管理员凭据
    TEST_ADMIN_USERNAME=
    TEST_ADMIN_PASSWORD=

    # 默认用户凭据 (根据环境自动选择 TEST_ 或 PROD_)
    DEFAULT_USERNAME=
    DEFAULT_PASSWORD=

    # 浏览器配置
    BROWSER=chromium
    HEADLESS=true
    DEFAULT_TIMEOUT=10

    # 日志级别 (DEBUG, INFO, WARNING, ERROR)
    LOG_LEVEL=INFO

    # 邮件通知 (可选)
    EMAIL_ENABLED=false
    EMAIL_SMTP_SERVER=
    EMAIL_SENDER=
    EMAIL_PASSWORD=
    EMAIL_RECIPIENTS=
    ```

2.  **`.env`**:
    *   **作用**: 存储**本地开发环境**的**实际**环境变量值，包括开发时使用的敏感信息。
    *   **内容**: 根据本地环境需要，覆盖 `.env.example` 中的变量值。
    *   **版本控制**: **绝不**提交到版本控制库，应将其添加到 `.gitignore` 文件中。

    ```dotenv
    # .env 文件内容示例 (本地)
    # --------------------------
    # 注意: 这个文件不应提交到 git
    APP_ENV=test
    
    WEB_BASE_URL=http://localhost:8080
    API_BASE_URL=http://localhost:3000/api

    TEST_ADMIN_USERNAME=local_admin
    TEST_ADMIN_PASSWORD=local_secret_password

    DEFAULT_USERNAME=${TEST_ADMIN_USERNAME} # 可以引用其他变量
    DEFAULT_PASSWORD=${TEST_ADMIN_PASSWORD}

    HEADLESS=false # 本地调试时可能需要关闭 headless
    LOG_LEVEL=DEBUG
    ```

3.  **`config/settings.yaml`**:
    *   如"核心原则"所述，定义框架的基础配置和通用默认值。
    ```yaml
    # config/settings.yaml 示例片段
    # -------------------------------
    web:
      output:
        directory: "output/web"
      timeouts:
        default: ${env:DEFAULT_TIMEOUT:-10} # 从环境变量获取，默认10秒
        
    # 通用邮件默认配置 (环境可覆盖)
    notification:
      email:
        enabled: ${env:EMAIL_ENABLED:-false} # 默认禁用
        use_ssl: true
        smtp_port: 465 # 常用 SSL 端口
        pop3_port: 995 # 常用 SSL 端口
        pop3_use_ssl: true

    log:
      format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
      default_level: ${env:LOG_LEVEL:-INFO} # 从环境变量获取，默认INFO

    # 注意: 没有环境特定的 URL 或凭据
    # 注意: 不应包含页面选择器等与UI强耦合的配置
    ```

4.  **`config/env/*.yaml`** (例如: `test.yaml`, `prod.yaml`):
    *   如"核心原则"所述，定义特定环境的配置，并引用环境变量。
    ```yaml
    # config/env/test.yaml 示例片段
    # -----------------------------
    environment: test

    web:
      # 直接引用环境变量
      base_url: "${env:WEB_BASE_URL}"
      browser: "${env:BROWSER:-chromium}" # 默认 chromium
      headless: ${env:HEADLESS:-false} # 测试环境默认显示浏览器
      timeout: ${env:DEFAULT_TIMEOUT:-10} # 使用默认值或环境变量覆盖
      slow_mo: ${env:SLOW_MO:-0} # 默认无慢放

    api:
      base_url: "${env:API_BASE_URL}"
      timeout: ${env:DEFAULT_TIMEOUT:-10} # 使用默认值或环境变量覆盖

    credentials:
      admin:
        username: "${env:TEST_ADMIN_USERNAME}" # 必须来自环境变量/secrets
        password: "${env:TEST_ADMIN_PASSWORD}" # 必须来自环境变量/secrets
      default:
        username: "${env:TEST_DEFAULT_USERNAME}" # 必须来自环境变量/secrets
        password: "${env:TEST_DEFAULT_PASSWORD}" # 必须来自环境变量/secrets

    # 测试环境邮件配置
    notification:
      email:
        enabled: ${env:EMAIL_ENABLED:-true} # 测试环境默认启用邮件
        smtp_server: "${env:EMAIL_SMTP_SERVER}"
        sender: "${env:EMAIL_SENDER}"
        password: "${env:EMAIL_PASSWORD}" # 必须来自环境变量/secrets
        recipients: "${env:EMAIL_RECIPIENTS}" # 收件人必须来自环境变量/secrets

    log:
      # 测试环境日志级别可以更详细
      default_level: ${env:LOG_LEVEL:-DEBUG}
    ```

## 变量命名规范

*   **格式**: 使用大写字母和下划线 (`SNAKE_CASE`)。
*   **描述性**: 名称应清晰、准确地反映变量的用途（例如 `DATABASE_URL`, `API_KEY`）。
*   **通用性**: 优先使用通用的角色或概念名称（例如 `ADMIN_USERNAME`, `DEFAULT_PASSWORD`），而不是特定于某个系统的名称（例如避免 `OMP_PASSWORD`）。环境变量的具体值会根据部署环境的不同而变化。
*   **环境前缀 (可选)**: 对于少数确实需要在变量名中区分环境的场景，可以考虑使用前缀（例如 `PROD_API_KEY`, `TEST_DATABASE_URL`），但优先通过 `config/env/*.yaml` 结合通用变量名来管理。

    **示例:**
    *   **推荐**: `WEB_BASE_URL`, `ADMIN_USERNAME`, `API_REQUEST_TIMEOUT`, `EMAIL_SMTP_SERVER`
    *   **不推荐**: `url`, `admin`, `timeout`, `server` (过于模糊)
    *   **避免**: `OMP_URL`, `JIRA_PASS` (过于系统特定，除非框架强耦合该系统)
    *   **谨慎使用**: `PROD_DATABASE_URL`, `TEST_API_KEY` (仅在无法通过 `env/*.yaml` 管理时使用)

## 配置加载与优先级

*   **标准加载顺序**: 环境变量 > `.env` 文件 (如果框架加载) > `config/env/{environment}.yaml` > `config/settings.yaml`。
*   框架应实现一个明确的配置加载器，按此优先级顺序合并配置源。

    **示例: `web.base_url` 的值如何确定?**

    假设当前环境是 `test`，框架加载配置时：
    1.  **检查环境变量**: 是否直接设置了 `WEB_BASE_URL` 环境变量？
        *   是: 使用环境变量的值 (最高优先级)。例如 `export WEB_BASE_URL=https://staging.example.com`。
        *   否: 继续下一步。
    2.  **检查 `.env` 文件**: 本地是否存在 `.env` 文件且包含 `WEB_BASE_URL`？
        *   是: 使用 `.env` 文件中的值。例如 `WEB_BASE_URL=http://localhost:8080`。
        *   否: 继续下一步。
    3.  **检查 `config/env/test.yaml`**: 该文件中是否定义了 `web.base_url`？
        *   是: 使用 `test.yaml` 中的定义。该定义通常会引用环境变量 (`"${env:WEB_BASE_URL}"`)。如果此时对应的环境变量 (`WEB_BASE_URL`) 没有在步骤1或2中设置，则该配置项可能解析为空或导致错误（取决于配置库的处理方式）。
        *   否: 继续下一步。
    4.  **检查 `config/settings.yaml`**: 该文件中是否定义了 `web.base_url`？
        *   是: 使用 `settings.yaml` 中的值（通常不推荐在这里定义基础URL）。
        *   否: `web.base_url` 未定义。

## 配置加载器实现

框架应提供一个统一的配置加载器（例如 `src/utils/config/manager.py`），它应该：

```python
from typing import Dict, Any, Optional
import os
import yaml
from pathlib import Path

def load_config() -> Dict[str, Any]:
    """加载配置，遵循正确的优先级
    
    加载顺序：settings.yaml -> env/{APP_ENV}.yaml -> 环境变量覆盖
    
    Returns:
        Dict[str, Any]: 合并后的配置字典
    """
    # 1. 确定环境
    app_env = os.environ.get("APP_ENV", "test")  # 默认为test环境
    
    # 2. 加载基础配置
    config_path = Path("config/settings.yaml")
    if not config_path.exists():
        raise FileNotFoundError(f"基础配置文件不存在: {config_path}")
        
    with open(config_path, "r") as f:
        config = yaml.safe_load(f)
        
    # 3. 加载环境特定配置
    env_config_path = Path(f"config/env/{app_env}.yaml")
    if env_config_path.exists():
        with open(env_config_path, "r") as f:
            env_config = yaml.safe_load(f)
            # 深度合并配置
            config = deep_merge(config, env_config)
    
    # 4. 环境变量覆盖
    config = resolve_env_vars(config)
    
    return config

def resolve_env_vars(config: Dict[str, Any]) -> Dict[str, Any]:
    """递归解析配置中的环境变量引用
    
    将 ${env:VAR_NAME} 或 ${env:VAR_NAME:-default} 格式的值
    替换为对应的环境变量值
    
    Args:
        config: 配置字典
        
    Returns:
        Dict[str, Any]: 解析后的配置字典
    """
    # 实现环境变量引用解析
    # ... 此处省略实现细节
    
    return config

def deep_merge(base: Dict, override: Dict) -> Dict:
    """深度合并两个字典
    
    Args:
        base: 基础字典
        override: 覆盖字典（优先级更高）
        
    Returns:
        Dict: 合并后的字典
    """
    # 实现字典深度合并
    # ... 此处省略实现细节
    
    return result
```

## 本地开发 vs CI 环境

| 配置方面 | 本地开发环境 | CI/CD 环境 |
|---------|------------|-----------|
| `APP_ENV` 设置 | 通过 `.env` 文件 | 通过 CI 配置或基于分支逻辑 |
| 敏感信息来源 | `.env` 文件（不提交到版本控制） | CI 平台的 Secrets 管理 |
| 默认模式 | 通常为非无头模式便于调试 | 通常为无头模式（更快、更稳定） |
| 日志级别 | 通常为 DEBUG（详细日志） | 通常在生产环境为 INFO/WARNING |
| 配置优先级 | 同样遵循配置层次结构 | 同样遵循配置层次结构 |

## CI/CD 环境集成

在持续集成/持续部署 (CI/CD) 流水线中:
*   **严禁**使用 `.env` 文件。
*   环境变量应通过 CI/CD 平台提供的 **Secrets Management** 机制安全地注入到执行环境中。
*   **必须**设置 `APP_ENV` 以区分环境。

### CI/CD 最佳实践示例

#### GitHub Actions 示例

```yaml
jobs:
  test:
    # 环境决策逻辑：开发分支使用测试环境，主分支使用生产环境
    env:
      APP_ENV: ${{ github.ref == 'refs/heads/develop' && 'test' || 'prod' }}
    
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: 3.11
          
      - name: Install dependencies
        run: |
          pip install poetry
          poetry install
          
      - name: Run tests
        env:
          # 根据APP_ENV选择对应环境的Secrets
          WEB_BASE_URL: ${{ env.APP_ENV == 'test' 
                          && secrets.TEST_WEB_URL 
                          || secrets.PROD_WEB_URL }}
          API_BASE_URL: ${{ env.APP_ENV == 'test' 
                         && secrets.TEST_API_URL 
                         || secrets.PROD_API_URL }}
          # 账号凭据                   
          TEST_ADMIN_USERNAME: ${{ secrets.TEST_ADMIN_USER }}
          TEST_ADMIN_PASSWORD: ${{ secrets.TEST_ADMIN_PASS }}
          PROD_ADMIN_USERNAME: ${{ secrets.PROD_ADMIN_USER }}
          PROD_ADMIN_PASSWORD: ${{ secrets.PROD_ADMIN_PASS }}
          # 运行参数
          LOG_LEVEL: ${{ env.APP_ENV == 'test' && 'DEBUG' || 'INFO' }}
          HEADLESS: 'true'  # CI 环境通常使用无头模式
        run: poetry run pytest tests/
```

#### GitLab CI/CD 示例

```yaml
variables:
  # 默认环境（可被特定任务覆盖）
  APP_ENV: test

test:prod:
  stage: test
  # 仅在主分支或带有prod标签时执行生产环境测试
  only:
    - main
    - tags: [prod-*]
  variables:
    APP_ENV: prod
  script:
    # 可使用条件脚本注入不同环境的变量
    - |
      if [ "$APP_ENV" = "test" ]; then
        export WEB_BASE_URL="$TEST_WEB_URL"
        export API_BASE_URL="$TEST_API_URL"
      else
        export WEB_BASE_URL="$PROD_WEB_URL"
        export API_BASE_URL="$PROD_API_URL" 
      fi
    - poetry run pytest tests/
```

## 最佳实践

*   **保持同步**: 定期审查和更新 `.env.example` 文件，确保其反映了当前代码库所需的所有环境变量。
*   **文档一致**: 确保 `.env.example` 与项目文档（如 `README.md` 或本文件）中关于环境设置的说明保持一致。
*   **清晰指引**: 在项目 `README.md` 中提供清晰的指导，说明如何基于 `.env.example` 创建和配置本地的 `.env` 文件。
*   **CI安全**: 确保CI/CD流程中不打印或记录敏感信息（如密码、Token）。
*   **Page Object模式**: 页面选择器应定义在Page Object类中，而非配置文件中，以提高代码内聚性。